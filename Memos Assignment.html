<!DOCTYPE html PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<!-- saved from url=(0081)https://cs-web.bu.edu/fac/richwest/cs350_spring_2021/assignments/memos/memos.html -->
<html><div id="translate-button" style="background-color: white;"><img src="data:image/png;base64,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"></div><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    <meta name="GENERATOR" content="Mozilla/4.77 [en] (X11; U; Linux
      2.4.9-6custom i686) [Netscape]">
    <meta name="Author" content="Rich West">
    <title>CS350</title>
  </head>
  <body vlink="#55188a" text="#000000" link="#0000ef" alink="#ff0000" bgcolor="#ffffff">
    <h1>The MemOS Memory Reporting System<br>
    </h1>
    By Rich West, Boston University.<br>
    <br>
    **** THIS PROJECT CAN BE PERFORMED IN GROUPS OF TWO ****<br>
    If working in a group of two, only one person is required to submit
    a solution via gradescope. In a README file, please include the name
    of the other person.<br>
    <h2>Background&nbsp; </h2>
    <p>In this primer, you are going to write a very simple OS. Okay,
      it's not a particularly useful OS but it will provide a way to
      understand how systems are booted, and how system information is
      displayed on the screen. The idea is to bootstrap a program that
      probes the system BIOS and reports the amount of physical memory
      available in your machine. This is then displayed as a message, in
      the form:<br>
    </p>
    <p>"MemOS: Welcome *** System Memory is: XXXMB"<br>
    </p>
    <p>The value XXX is replaced by the actual memory your system has
      available.<br>
    </p>
    <p>You can use any of the BIOS functions available for detecting
      memory except BIOS call E801 (shown in class). Bonus points will
      be given for detecting memory using BIOS INT 0x15, EAX=0xE820 and
      reporting <b>only the usable RAM</b> (known as Type 1 memory) as
      opposed to all memory. You can find more on the <a href="https://wiki.osdev.org/Detecting_Memory_%28x86%29">osdev</a>
      page for the five types of memory reported using BIOS INT 0x15,
      EAX=0xE820. <br>
    </p>
    <h2> Step 1: Building a Virtual Disk</h2>
    <p>The first step is to build a virtual disk for MemOS. To do this
      you should follow the general <a href="https://cs-web.bu.edu/fac/richwest/cs350_spring_2021/assignments/memos/disk-image-HOWTO" moz-do-not-send="true">guidelines</a> I provided for creating a
      simple disk image.<br>
      Tis disk image can be used with any virtual machine PC emulation
      tools such as QEMU, BOCHS, virtualbox, etc. QEMU comes
      pre-installed in Puppy Linux, and the steps for creating your
      virtual disk are recommended to be performed in the provided Puppy
      Linux virtual machine.<br>
      &nbsp;<br>
      An example using <font face="Courier New, Courier, monospace">dd</font>
      to create a virtual disk file is as follows:<br>
    </p>
    <p><font face="Courier New, Courier, monospace">$dd if=/dev/zero
        of=disk.img bs=1k count=32760<br>
      </font></p>
    <p>A similar command is shown in the guidelines for creating a
      virtual disk, except that example assumes a block size of 512
      bytes. It does not matter in this case as all we are doing is
      allocating a number of bytes to our file that equals the size of a
      hypothetical disk partition.<font face="Courier New, Courier,
        monospace"><br>
      </font></p>
    <p>In this example, we simply use the pseudo-device <font face="Courier New, Courier, monospace">/dev/zero</font> to fill
      an output file, <font face="Courier New, Courier, monospace">disk.img</font>,
      with zero'd bytes, with a block size of 1024 and a count of blocks
      equal to 32760. &nbsp; This will create a file whose size is
      32760*1024 bytes. For larger or smaller files, you can choose
      different count values. Similarly, you can change the block size
      as it's not particularly important unless we're dealing with a
      real disk device.<br>
    </p>
    <p>If you have <font face="Courier New, Courier, monospace">qemu-img</font>,
      you can create a raw disk image using the following command as an
      example:<br>
    </p>
    <p><font face="Courier New, Courier, monospace">$qemu-img create -f
        raw disk.img 32760K</font><br>
    </p>
    <p>In choosing the size of your virtual disk, you should be aware of
      disk geometries. In a real disk, at least older ones based on CHS
      geometries rather than logical block addressing (LBA), the size is
      calculated as:</p>
    <p>cylinders * heads * sectors * sector-size<br>
    </p>
    <p>This is equivalent to:<br>
    </p>
    <p>cylinders * (tracks / cylinder) * (sectors / track) * sector-size<br>
    </p>
    <p>Let's assume that we're going to adopt the default
      sectors-per-track value for DOS compatibility. This is 63.<br>
      Also, let's assume we have a complete geometry as follows:<br>
    </p>
    <p>Cylinders = 65<br>
      Heads = 16 (same as tracks / cylinder)<br>
      Sectors = 63&nbsp; (actually, sectors / track)<br>
      Sector-size = 512 bytes<br>
      <span style="text-decoration: underline;"></span></p>
    <p><span style="text-decoration: underline;"><span style="text-decoration: underline;"></span></span>This gives
      us a disk size of:<br>
    </p>
    <span style="text-decoration: underline;"></span>65 * 16 * 63 * 512
    = 32760KB (where 1KB is 1024 bytes)<br>
    <br>
    Once we have a raw virtual disk partition file, we can start to
    properly configure its geometry and its filesystem. Then, we can
    install a bootloader.<br>
    <br>
    You should follow the guidelines to create your formatted disk
    image. You only need to install GRUB if you use it to boot your OS,
    which is necessary for memos-2, described below. It is not needed
    for memos-1.<br>
    <br>
    If installing GRUB, we will assume the bootloader is based on
    version 1 (GRUB legacy) rather than GRUB2. You will need to copy <font face="Courier New, Courier, monospace">stage1</font>, <font face="Courier New, Courier, monospace">stage2</font>, and <font face="Courier New, Courier, monospace">e2fs_stage1_5</font> to a <font face="Courier New, Courier, monospace">/boot/grub</font> directory
    on your virtual disk, as described in the HOWTO step 5. Then you
    will need to install stage1 in the master boot record (MBR) region
    of your disk image, using the interactive grub shell. Once
    successfully installed, you are ready for Step 2...<br>
    <h2>Step 2: Writing the MemOS Code</h2>
    Here, you will have to write an x86 assembly program, called <font face="Courier New, Courier, monospace">memos-X.s</font>, where X
    is replaced with "1" or "2" depending on the version (described
    later). To help, I have provided a test program called <font face="Courier New, Courier, monospace"><a href="https://cs-web.bu.edu/fac/richwest/cs350_spring_2021/assignments/memos/vga16.s">vga16.s</a></font>,
    written for use with the GNU assembler, <font face="Courier New,
      Courier, monospace">gas</font>. You should study <font face="Courier New, Courier, monospace"> vga16.s</font> to see how
    it works. Intel's Software Developers Manual <a href="http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html">
      Volume 2</a> (Instruction Set) is helpful here. <br>
    <br>
    Notice how the size of vga16.s is limited to 512 bytes. It's
    actually possible to load this code, after assembly and linkage into
    the MBR of your disk partition and treat it as a bootable program.
    This is because it has a valid boot signature 0xAA55 in the last two
    bytes of the 512 byte sector.<br>
    <br>
    To assemble and link your <font face="Courier New, Courier,
      monospace">memos-X.s</font> program, you will need to follow the
    instructions at the bottom of <font face="Courier New, Courier,
      monospace">vga16.s</font> as a guideline. What is missing is the
    linker script to complete the linkage of your program. Here, I
    provide the <a href="https://cs-web.bu.edu/fac/richwest/cs350_spring_2021/assignments/memos/vga.ld">linker script</a> for <font face="Courier New, Courier, monospace">vga16.s</font>. You should
    read the info or man pages on GNU <font face="Courier New, Courier,
      monospace">ld</font>, which is part of the binutils package, to
    understand the format of linker scripts. Notice how, at the bottom
    of <font face="Courier New, Courier, monospace">vga16.s</font> we
    use <font face="Courier New, Courier, monospace">dd</font> again,
    to create a sector image of 512 bytes that will fit in an MBR if
    desired. Here, we skip the first 4096 bytes to bypass the object
    file program header, generated by <font face="Courier New, Courier,
      monospace">ld</font>. This is because the assembler (<font face="Courier New, Courier, monospace">as</font>) and linker (<font face="Courier New, Courier, monospace">ld</font>) produce an
    output file in <a href="http://wiki.osdev.org/ELF">ELF</a> binary
    format and what we really want are just the program sections if
    we're to map this code into an MBR.<br>
    <br>
    Now, let's backtrack a moment. It is possible using a PC emulator
    such as QEMU to boot the resultant binary, <font face="Courier New,
      Courier, monospace">memos-X,</font> without mapping it to a
    virtual disk. To do this, we can assume it is written just like <font face="Courier New, Courier, monospace">vga16_test</font> (created
    from <font face="Courier New, Courier, monospace">vga16.s</font>
    using <font face="Courier New, Courier, monospace">dd</font>). We
    can execute <font face="Courier New, Courier, monospace">memos-X</font>
    as follows:<br>
    <br>
    <font face="Courier New, Courier, monospace">$qemu -hda memos</font>-X









    (depending on your version of qemu, you might need to use
    qemu-system-i386 or something similar for the binary name)<br>
    <br>
    The -hda flag, above, is actually optional here and won't really
    affect anything as it stands.<br>
    <br>
    <h2>First Deliverable</h2>
    For the first solution to the problem of detecting memory, you
    should produce a file called <font face="Courier New, Courier,
      monospace">memos-1.s</font> which when assembled and linked into a
    512-byte file called <font face="Courier New, Courier, monospace">memos-1</font>
    will run as standalone boot code. Your solution will use BIOS
    interrupts to detect memory and write it to the screen. For this you
    will need to understand:<br>
    <ul>
      <li>the <a href="http://wiki.osdev.org/BIOS">BIOS</a></li>
      <li>ways to use the BIOS to <a href="http://wiki.osdev.org/Detecting_Memory_%28x86%29">detect
          memory</a></li>
      <li>how to use the BIOS to write to the VGA display. Here, you
        should use INT 0x10 interrupts, similar to how printing is done
        in <font face="Courier New, Courier, monospace">vga16.s</font>.<br>
      </li>
    </ul>
    <p>The next test is to show that you can boot your <font face="Courier New, Courier, monospace">memos-1</font> code
      assembled and linked into the MBR of a virtual disk.<b> The first
        deliverable only requires that you </b><b>submit the source
        code </b><b><font face="Courier New, Courier, monospace">memos-1.s</font></b><b>,
        a linker script called </b><b><font face="Courier New, Courier,
          monospace">memos-1.ld</font></b><b>, a </b><b><font face="Courier New, Courier, monospace">Makefile</font></b><b>
        to assemble and link </b><b><font face="Courier New, Courier,
          monospace">memos-1.s</font></b><b> into a binary image called
      </b><b><font face="Courier New, Courier, monospace">memos-1</font></b><b>,
        and a </b><b><font face="Courier New, Courier, monospace">README-1</font></b><b>
        file</b>. README-1 should document exactly the steps taken to
      get your <font face="Courier New, Courier, monospace">memos-1</font>
      binary into the virtual disk's MBR, so that it can execute to
      produce the output strings at the top of this document.<br>
    </p>
    <p>&nbsp;Specifically, the message:<br>
    </p>
    <p>&nbsp; "MemOS: Welcome *** System Memory is: XXXMB"<br>
    </p>
    <p>You should use gradescope to submit all your files (discounting
      the virtual disk image) to a subdirectory called MEMOS. Include
      the linker script, memos-1.s files, a Makefile and README-1.<br>
    </p>
    <h2>Second Deliverable <br>
    </h2>
    <p>Here, you will create a file called <font face="Courier New,
        Courier, monospace">memos-2.s</font> and appropriate linker
      scripts to generate a binary that is booted by GRUB. Here, we will
      assume <i>legacy</i> GRUB rather than GRUB version 2. You will
      need to go back to the virtual disk creation described above and
      install GRUB in your MBR (or, alternatively, create a second
      virtual disk and install GRUB on that). This is documented in step
      5 of the BOCHS virtual disk HOWTO. Then you will need to add a
      file called <font face="Courier New, Courier, monospace">menu.lst</font>
      to <font face="Courier New, Courier, monospace">/boot/grub</font>
      on your virtual disk. To do this, make sure you have mounted your
      virtual disk as a loopback device. For example, you can do this as
      follows:<br>
    </p>
    <p><font face="Courier New, Courier, monospace">$mount -t ext2
        disk.img /mnt -o loop,offset=32256</font><br>
    </p>
    <p>The offset, above, is because the ext2 filesystem begins after
      the first track on your virtual disk. If you have formatted your
      disk to have a sectors-per-track value of 63 (the DOS
      compatibility value) then the first track has a size of 63*512
      bytes, which is where the 32256 value comes from. To make sure you
      use 63 sectors/track when creating <font face="Courier New,
        Courier, monospace">disk.img</font>, be sure that your version
      of <font face="Courier New, Courier, monospace">fdisk</font> is
      running in DOS compatibility mode. If it's an older version, it
      will automatically assume 63 sectors/track. If you get a value
      such as 2048 as your default, you'll need to force DOS
      compatibility by using <font face="Courier New, Courier,
        monospace">fdisk -c=dos</font> ... when creating your virtual
      disk.</p>
    <p>The <font face="Courier New, Courier, monospace">menu.lst</font>
      file will look something like the following:<br>
    </p>
    <p><font face="Courier New, Courier, monospace">title MemOS<br>
        root (hd0,0)<br>
        kernel /boot/memos-2</font><br>
    </p>
    <p>This file is interpreted by GRUB to determine which OS should
      actually be loaded into memory. GRUB is intelligent enough to be
      able to read the filesystem of your bootable disk partition. This
      is where <font face="Courier New, Courier, monospace">e2fs_stage1_5<font face="Helvetica, Arial, sans-serif"> </font></font>is used by
      GRUB. Finally, the second stage of bootloading copies your
      bootable system into memory. However, your OS image, <font face="Courier New, Courier, monospace">memos-2</font>, will not
      load because it does not have a valid GRUB-compliant multiboot
      header. Since GRUB is based on the multiboot spec, it requires the
      OS to have a special magic number in the first 4096 bytes of
      memory. So, to get your <font face="Courier New, Courier,
        monospace">memos-2</font> binary to be booted by GRUB you'll
      need to add something like the following at the beginning of<font face="Courier New, Courier, monospace"> memos-2.s</font>:<br>
    </p>
    <font face="Courier New, Courier, monospace">_start:<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jmp real_start<br>
      <br>
    </font> <font face="Courier New, Courier, monospace">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Multiboot header --
      Safe to place this header in 1st page of memory for GRUB */<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .align 4<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .long 0x1BADB002 /*
      Multiboot magic number */<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .long 0x00000003 /*
      Align modules to 4KB, req. mem size */<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;











      /* See 'info multiboot' for further info */<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .long 0xE4524FFB /*
      Checksum */<br>
      <br>
      real_start:</font> <font face="Courier New, Courier, monospace"><br>
      <br>
    </font> <font face="Courier New, Courier, monospace">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # This is where the
      rest of your program goes<br>
    </font> <br>
    Once you have successfully generated your <font face="Courier New,
      Courier, monospace">memos-2</font> binary image, you should copy
    it to <font face="Courier New, Courier, monospace">/boot</font>
    within your virtual disk. To do this, you'll need your disk.img
    mounted as a loopback device again, as described earlier. <br>
    <br>
    <h3>But it Still Doesn't Work!</h3>
    If you've got this far with <font face="Courier New, Courier,
      monospace">memos-2</font>, congratulations! However, in all
    likelihood nothing is working. This is because GRUB boots your OS
    code into a protected mode environment. In protected mode, you no
    longer have access to the BIOS, so all your real-mode software
    interrupts will not work. At this stage you can either write some
    code to force your <font face="Courier New, Courier, monospace">memos-2</font>
    code back into real-mode, or you can "poke" directly into VGA video
    memory, the bytes that you want displayed. To do this, you need to
    write to video memory, which is mapped at address 0xB8000 for text
    mode graphics. Further details can be found on the OSDEV wiki:<br>
    <ul>
      <li>How to <a href="http://wiki.osdev.org/Printing_to_Screen">print











          a character to the screen</a></li>
      <li>How to work with VGA in <a href="http://wiki.osdev.org/Text_UI">text mode</a><br>
      </li>
    </ul>
    Note that GRUB boots your system in VGA Text Mode so you will not
    have to set this yourself. You can also use GRUB itself to report
    how much memory your system has. <br>
    <br>
    If you get this far you should be able to use a PC emulator to boot
    your disk image and display text on the screen. For QEMU, type
    something like:<br>
    <br>
    <font face="Courier New, Courier, monospace">$qemu -hda disk.img</font><br>
    <span style="font-weight: bold;"></span>
    <h2>Submission</h2>
    <p>You should use <font face="Courier New, Courier, monospace">gradescope</font>
      to submit files to a <font face="Courier New, Courier, monospace">MEMOS</font>
      directory, as stated earlier. <br>
    </p>
    <p><b>As stated above (but repeated here), the first deliverable for
        memos-1 requires you to submit memos-1.s, memos-1.ld, Makefile,
        and README-1. </b>README-1 documents the steps to copy your
      memos-1 image to the MBR of your virtual disk image. Be sure to
      test your virtual disk image works with memos-1 so that you can
      verify your instructions in README-1.<br>
    </p>
    <p><b>The second deliverable requires you to submit:</b><b> </b><b><font face="Courier New, Courier, monospace">memos-2.s</font></b><b>,
      </b><b><font face="Courier New, Courier, monospace">memos-2.ld</font></b><b>,
      </b><b><font face="Courier New, Courier, monospace">Makefile</font></b><b>,
      </b><b><font face="Courier New, Courier, monospace">README-2</font></b><b>,
      </b><b><font face="Courier New, Courier, monospace">memos-2.img</font></b><b>.
      </b><br>
    </p>
    <ul>
      <li>Put in <font face="Courier New, Courier, monospace">README-2</font>
        the names and BUIDs of everyone in the same team (up to two
        people), and the <b>byte </b><b>size</b> and <b>configuration</b>
        (cylinders, heads, sectors) of your virtual disk <font face="Courier New, Courier, monospace">memos-2.img</font>.<br>
      </li>
      <li>m<font face="Courier New, Courier, monospace">emos-2.img</font>
        will be a virtual disk image that includes all GRUB files, <font face="Courier New, Courier, monospace">menu.lst</font> and <font face="Courier New, Courier, monospace">memos-2</font>.</li>
      <li><font color="#33cc00"><b><font color="#ff0000">You should
              create <font face="Courier New, Courier, monospace">memos-2.img</font>
              to have the following configuration (cylinders=10+last 2
              digits of your BUID, heads=16, sectors=63).</font></b> </font>If

        you work in a group of two, put in <font face="Courier New,
          Courier, monospace">README-2</font> which person's BUID you
        chose to use for your virtual disk image. <br>
      </li>
    </ul>
    <h2>Puppy Linux<br>
    </h2>
    <ul>
      <li>You can use the Puppy Linux image already discussed in labs
        (which is the same as used for CS552, available <a moz-do-not-send="true" href="http://www.cs.bu.edu/fac/richwest/class_files/cs552.vdi">here</a>).<br>
      </li>
      <li>Puppy Linux provides support for legacy GRUB. You can run the
        GRUB shell, and access <font face="Courier New, Courier,
          monospace">stage1</font>, <font face="Courier New, Courier,
          monospace">stage2</font> and <font face="Courier New,
          Courier, monospace">e2fs_stage1_5</font> files in <font face="Courier New, Courier, monospace">/boot/grub</font>
        within the Puppy Linux virtual disk image<font face="Courier
          New, Courier, monospace">.</font></li>
    </ul>
    <h2>Using QEMU to Test memos-1 and memos-2</h2>
    <ul>
      <li>QEMU is included in Puppy Linux, along with vncviewer, so you
        can test your OS development inside another guest OS!<br>
      </li>
      <li>You can type: <font face="Courier New, Courier, monospace">qemu-system-i386







          -hda memos-1 -vnc :screen_num</font> (where <font face="Courier New, Courier, monospace">screen_num</font> is
        replaced by an integer). <br>
      </li>
      <ul>
        <li>Then, if you type:&nbsp; <font face="Courier New, Courier,
            monospace">vncviewer :screen_num </font>you will be able to
          see the output.</li>
      </ul>
      <li>For <font face="Courier New, Courier, monospace">memos-2</font>,
        you can do exactly the&nbsp; same as above, replacing <font face="Courier New, Courier, monospace">memos-1</font> with the
        name of your virtual disk image. Alternatively, if you don't
        want to copy memos-2 into your disk image you can quickly test
        it using QEMU's very useful built-in grub support. You can do
        the following for testing and development purposes: <font face="Courier New, Courier, monospace">qemu-system-i386
          -kernel memos-2</font></li>
      <li>You can vary the amount of memory available to your <font face="Courier New, Courier, monospace">memos-1</font> or <font face="Courier New, Courier, monospace">memos-2</font> systems
        by adding "<font face="Courier New, Courier, monospace">-m XX</font>"
        to your <font face="Courier New, Courier, monospace">qemu-system-i386</font>
        command, where XX is the amount of memory you want to restrict
        to your OS. Note, you cannot allocate more memory than is
        available to the system running QEMU. If using QEMU in Puppy
        Linux, you will be restricted by the amount of memory your Puppy
        virtual machine has. Here, we will likely not test above 128MB.
        <br>
        <font face="Courier New, Courier, monospace"></font></li>
    </ul>
    <p>Happy Programming!<br>
    </p>
    <blockquote>&nbsp;</blockquote>
    <br>
    &nbsp; <br>
    &nbsp;
  

</body><div id="edge-translate-notifier-container" class="edge-translate-notifier-center"></div></html>